---
title: js执行过程
date: 2022-01-07 18:58:00
permalink: /pages/c97cca/
categories: 
  - 前端
  - JavaScript文章
tags: 
  - 
---

# js执行过程

js是单线程解释型弱类型语言

* 编译型：编译型语言是代码在运行前编译器将人类可以理解的语言（编程语言）转换成机器可以理解的语言
* 解释型： 解释型语言也是人类可以理解的语言（编程语言），也需要转换成机器可以理解的语言才能执行，但是是在运行时转换的。所以执行前需要环境中安装了解释器；但是编译型语言编写的应用在编译后能直接运行。

js引擎线程执行过程的三个阶段

* 语法分析阶段
* 预编译阶段(执行阶段)
* 解释执行阶段（执行阶段）

## 语法分析阶段

分析该js脚本代码块的语法是否正确，如果出现不正确，则向外抛出一个语法错误（SyntaxError），停止该js代码块的执行，然后继续查找并加载下一个代码块；如果语法正确，则进入预编译阶段

* 词法分析/分词，将字符流(char stream)转换为记号流(token stream)，由字符串组成的字符分解成有意义的代码块，这些代码块称为词法单元。例如：一段 JS 代码 var name = 'Hello Flutter'; 会被分解为词法单元：var、name、=、Hello Flutter、;最小词法单元主要有空格、注释、字符串、数字、标志符、运算符、括号等。
* 语法分析/解析(Parsing)， 将词法单元流转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树称为 “抽象语法树” AST（Abstract Syntax Tree），词法分析和语法分析不是完全独立的，而是交错进行的，也就是说，词法分析器不会在读取所有的词法记号后再使用语法分析器来处理。在通常情况下，每取得一个词法记号，就将其送入语法分析器进行分析。语法分析的过程就是把词法分析所产生的记号生成语法树，通俗地说，就是把从程序中收集的信息存储到数据结构中，经过编译阶段的准备，JavaScript 代码在内存中已经被构建为语法树，然后 JavaScript 引擎就会根据这个语法树结构边解释边执行。

经过编译阶段的准备，JavaScript 代码在内存中已经被构建为语法树，然后 JavaScript 引擎就会根据这个语法树结构边解释边执行。

## 预编译阶段

js代码块通过语法分析阶段后，语法正确则进入预编译阶段。在分析预编译阶段之前，我们先了解一下js的运行环境，运行环境主要有三种：

* 全局环境
* 函数环境
* eval

```js
 function demo(params) {
  function demo1() {}
  demo1()
}
demo()
```

每进入一个不同的运行环境都会创建一个相应的执行上下文（Execution Context），那么在一段JS程序中一般都会创建多个执行上下文，js引擎会以栈的方式对这些执行上下文进行处理，形成函数调用栈（call stack），栈底永远是全局执行上下文（Global Execution Context），栈顶则永远是当前执行上下文。

* 首先进入全局环境，创建全局执行上下文（Global Execution Context），推入stack栈中
* 开始解释执行全局环境的代码
* 遇到demo()函数执行，进入到demo()函数，进入到新环境，创建demo函数执行上下文（bar Execution Context），推入stack栈中
* 在demo函数内部调用demo1函数，则再进入demo1函数运行环境，创建demo1函数执行上下文（demo1 Execution Context），推入stack栈中
* 执行demo1函数的相关代码，执行完，栈顶demo1函数执行上下文（foo Execution Context）首先出栈
* demo函数执行完毕，demo函数执行上下文（demo Execution Context）出栈
* Global Execution Context则在浏览器或者该标签页关闭时出栈

ps: 不同的运行环境执行都会进入代码预编译和执行两个阶段，语法分析则在代码块加载完毕时统一检验语法

### 执行上下文创建过程

* 创建变量对象（Variable Object）

* 建立作用域链（Scope Chain）

* 确定this的指向

#### 创建变量对象（Variable Object）

* 创建arguments对象：检查当前上下文中的参数，建立该对象的属性与属性值，仅在函数环境(非箭头函数)中进行，全局环境没有此过程
* 检查当前上下文的函数声明：按代码顺序查找，将找到的函数提前声明，如果当前上下文的变量对象没有该函数名属性，则在该变量对象以函数名建立一个属性，属性值则为指向该函数所在堆内存地址的引用，如果存在，则会被新的引用覆盖。
* 检查当前上下文的变量声明：按代码顺序查找，将找到的变量提前声明，如果当前上下文的变量对象没有该变量名属性，则在该变量对象以变量名建立一个属性，属性值为undefined；如果存在，则忽略该变量声明

函数声明提前和变量声明提升是在创建变量对象中进行的，且函数声明优先级高于变量声明。具体是如何函数和变量声明提前的可以看后面。创建变量对象发生在预编译阶段，但尚未进入执行阶段，该变量对象都是不能访问的，因为此时的变量对象中的变量属性尚未赋值，值仍为undefined，只有进入执行阶段，变量对象中的变量属性进行赋值后，变量对象（Variable Object）转为活动对象（Active Object）后，才能进行访问，这个过程就是VO –> AO过程。

#### 建立作用域链

通俗理解，作用域链由当前执行环境的变量对象（未进入执行阶段前）与上层环境的一系列活动对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。深入理解的话，创建作用域链，也就是创建词法环境，而词法环境有两个组成部分：

* 环境记录：存储变量和函数声明的实际位置
* 对外部环境的引用：可以访问其外部词法环境

#### 确定this的指向

## 执行过程

永远只有JS引擎线程在执行JS脚本程序，其他三个线程只负责将满足触发条件的处理函数推进事件队列，等待JS引擎线程执行， 不参与代码解析与执行。

* JS引擎线程： 也称为JS内核，负责解析执行Javascript脚本程序的主线程（例如V8引擎）

* 事件触发线程： 归属于浏览器内核进程，不受JS引擎线程控制。主要用于控制事件（例如鼠标，键盘等事件），当该事件被触发时候，事件触发线程就会把该事件的处理函数推进事件队列，等待JS引擎线程执行

* 定时器触发线程：主要控制计时器setInterval和延时器setTimeout，用于定时器的计时，计时完毕，满足定时器的触发条件，则将定时器的处理函数推进事件队列中，等待JS引擎线程执行。 注：W3C在HTML标准中规定setTimeout低于4ms的时间间隔算为4ms。

* HTTP异步请求线程：通过XMLHttpRequest连接后，通过浏览器新开的一个线程，监控readyState状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待JS引擎线程执行。 注：浏览器对通一域名请求的并发连接数是有限制的，Chrome和Firefox限制数为6个，ie8则为10个。
