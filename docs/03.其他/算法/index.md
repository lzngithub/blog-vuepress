---
title: 算法
date: 2023-10-16 22:18:43
permalink: /pages/bce8bc/
categories:
  - 其他
  - 算法
tags:
  -
---

# 算法

指令的结合，为解决特定问题而规定的一系列操作。通常有五个特性

1. 输入
2. 输出
3. 可行性
4. 有穷性
5. 确定性：每个步骤都是确定的。

评价算法的优劣性：从两个维度去评判，时间维度和空间维度

- 时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。
- 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。

算法是学不完的，算法是的最终目的是帮助我们更好的解决问题。

在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。所以我们如今已经不需要再特别关注一个算法的空间复杂度。用空间换时间。

## （Time）时间复杂度(O(n))

我们想要知道一个算法的「时间复杂度」，很多人首先想到的的方法就是把这个算法程序运行一遍，那么它所消耗的时间就自然而然知道了。

这种方式可以吗？当然可以，不过它也有很多弊端。
这种方式非常容易受运行环境的影响，在性能高的机器上跑出来的结果与在性能低的机器上跑的结果相差会很大。而且对测试时使用的数据规模也有很大关系。再者，我们在写算法的时候，还没有办法完整的去运行呢。

因此，另一种更为通用的方法就出来了：「 大 O 符号表示法 」，即 T(n) = O(f(n))，算法的渐进时间复杂度。

公式：

```text
T(n) = O(f(n))
```

- n: 问题规模。
- f(n): 每行代码执行次数之和。
- O：表示正比例关系。
- O(f(n)): 时间复杂度 = 表示代码执行时间的随问题规模 n 的正比例变化趋势。

例子：

```js
for (i = 1; i <= n; ++i) {
  j = i;
  j++;
}
```

T(n) = O(f(n)) = O(1 + n + n) = O(2n + 1) = O(2n) = O(n)

为什么可以这么去简化呢，因为大 O 符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。

对于一些排序算法，数据用例不一样，时间复杂度也不一样，会有最好最坏平均三种情况。

面试中说道算法的时间复杂度是多少指的都是一般情况，而不是指最坏的情况。但是如果面试官和我们深入探讨一个算法的实现以及性能的时候，就要时刻想着数据用例的不一样，时间复杂度也是不同的，这一点是一定要注意的。

### 常见的几种时间复杂度

下面几种时间复杂度，按照顺序是越来越差的（当 n 区域无穷大且常数项比较是一个普通数，不是类似于大数 10^7 这样的）。

- O(1): 常数阶，一个简单语句的时间复杂度，没有循环语句，跟问题规模没有关系。
- O(logn): 对数阶，底数忽略，没有意义
- O(n): 线性阶，只有一重循环，算法的执行频度和问题规模 n 呈线性增大关系。
- O(nlogn): 线性对数阶
- O(n^2): 平方阶
- O(n^3): 立方阶
- O(n^k): k 次方阶
- O(2^n): 指数阶
- O(n!): 阶乘

### 例子分析

求 x 的 n 次方

```js
function1 (x, n) {
  let result = 1;
  for(let i = 0; i< n; i++) {
    result = result * x
  }
  return result;
}
```

时间复杂度：O(n)

### 递归算法的时间复杂度

递归算法时间复杂度：递归次数 \* 每次递归的操作次数

可以采用树的方法分析递归次数，树上每一个节点对应一次调用，一颗深度为 k 的满二叉树的节点数为：2^k - 1

## （Space）空间复杂度

当数据规模发生变化时，计算占用空间的变化趋势

算法的存储量包括，

1. 算法本身所占用的空间
2. 输入变量占用空间
3. 算法辅助变量占用空间

其中输入变量占用空间跟算法无关，所以排除在外

空间复杂度是度量一个算法在运行过程中临时存储空间的大小，一般也作为问题规模 n 的函数，以数量级的形式给出

```text
S(n) = O(f(n))
```

### 归算法的空间复杂度

- 递归算法的空间复杂度 = 递归深度 n \* 每次递归所要的空间复杂度
