---
title: web安全
date: 2023-12-18 21:45:23
permalink: /pages/52e11b/
categories:
  - 工程工具
  - 模块化
tags:
  -
---

# web 安全

安全是 web 开发中非常重要的一环，是保障我们网站平稳的运行的很重要的因素，了解 web 安全，提升我们在这方面的认知。

## 简单了解 web 的攻击方式有哪些

1. xss：跨站脚本攻击（cross site sripting）
2. csrf：跨站请求伪造（cross site request forgery）
3. 点击劫持
4. 暴力攻击
5. 源码暴露
6. DDoS 攻击

## xss

攻击者在网站中嵌入恶意代码，当用户打开网站的时候，恶意代码被运行，可以用于盗取用户的 cookie，权限，账号密码或者下载病毒等。

### 嵌入代码的实现方式

1. 一般在用户界面可以输入的地方，比如：登陆，信息采集，评论区等，在这些地方去输入恶意代码;
2. 通过恶意链接，用户点击则会打开目标网站，执行恶意链接中的代码，比如一些搜索网站通过 url 去携带查询搜索参数。

### xss 分类

#### 1.反射型 xss

也叫非持久型 xss，顾名思义，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又将这部分返回给用户，恶意脚本在页面中被执行。一般发生在前后端一体的应用中，服务端逻辑会改变最终的网页代码。

反射型 XSS 的攻击步骤

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL 时，浏览器打开被攻击网站，向服务器发起请求，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

#### 2.基于 dom 的 xss 攻击

目前更流行前后端分离的项目，反射型 XSS 无用武之地。 但这种攻击不需要经过服务器，我们知道，网页本身的 JavaScript 也是可以改变 HTML 的，黑客正是利用这一点来实现插入恶意脚本。

基于 DOM 的 XSS 攻击步骤：

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL。
3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

#### 3.存储型 xss 攻击

又叫持久型 XSS，顾名思义，黑客将恶意 JavaScript 脚本长期保存在服务端数据库中，用户一旦访问相关页面数据，恶意脚本就会被执行。常见于搜索、微博、社区贴吧评论等。

存储型 XSS 的攻击步骤：

1. 攻击者将恶意代码提交到目标网站的数据库中。
2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

### 解决办法

解决办法：

- 尽量不要使用 eval 、innerHTML、setInterval 等可执行字符串的方法；
- 使用 Vue/React 技术栈，尽量不要使用 v-html/dangerouslySetInnerHTML 功能
- 对动态渲染的 html 标签做转义
- 渲染的数据都必须来自于服务端；尽量不要从 URL 等这种 DOM API
- 设置严格的 CSP，严格的 CSP 在 XSS 的防范中可以起到以下的作用：

#### Content Security Policy

使用 W3C 提出的 CSP (Content Security Policy，内容安全策略)，定义域名白名单，有以下作用：

- 禁止加载外域代码，防止复杂的攻击逻辑。
- 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。
- 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。
- 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。
- 合理使用上报可以及时发现 XSS，利于尽快修复问题。

## csrf

CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

### 攻击步骤

- 受害者登录 A 网站，并且保留了登录凭证（Cookie）
- 攻击者引诱受害者访问 B 网站
- B 网站向 A 网站发送了一个请求（这个就是下面将介绍的几种伪造请求的方式），浏览器请求头中会默认携带 A 网站的 Cookie
- A 网站服务器收到请求后，经过验证发现用户是登录了的，所以会处理请求

### csrf 攻击可以实现的原因

为什么在网站 B 向 A 网站发送了一个请求会默认携带 A 网站的 Cookie，这跟 cookie 的特点有关。

1. 读写 Cookie 有跨域限制，通常只能读取当前请求域名下的 cookie，也可以设置 Path 限制；
2. 浏览器在发起请求时，默认自动携带当前请求域名下的 Cookie，无论何种方式，如何发起的请求；
3. Cookie 有生命周期，只在会话期有效或者持久有效。

重点跟第二点有关，无论何种方式发起的请求，无论是不是在当前网站下发起的请求，默认自动携带请求域名下的 Cookie。

引言：其实 Google 浏览器版本更新至今，已经完全禁止当前域名下的跨域请求携带第三方 cookie 了，所以很大程度上，在客户端底座都预防了 CSRF 攻击，但是其他的浏览器，有没有做这一项限制不晓得，而一些安全测评机构肯定也不会做这方面的安全限制。

### 攻击实现方式

因为 csrf 是在第三方发起的请求，因此会受到浏览器同源策略的影响，因此一般是通过 html 标签的方式去发起请求，不会受到同源策略的影响。有 img form 等。

```html
<img src="http://bank.example/withdraw?amount=10000&for=hacker" />

<form action="http://bank.example/withdraw" method="POST">
  <input type="hidden" name="account" value="xiaoming" />
  <input type="hidden" name="amount" value="10000" />
  <input type="hidden" name="for" value="hacker" />
</form>
<script>
  document.forms[0].submit();
</script>

<a
  href="http://test.com/csrf/withdraw.php?amount=1000&for=hacker"
  taget="_blank"
>
  重磅消息！！
  <a
/></a>
```

以上链接都可以发起请求。

### 防御方式

CSRF 通常发生在第三方域名，并且 CSRF 攻击者不能获取到受害者的 cookie 等信息，只是借用他们的登录状态来伪造请求。所以我们可以针对这两点来制定防范措施：

#### 同源检测

既然 CSRF 大多来自第三方网站，那么我们就直接禁止第三方域名（或者不受信任的域名）对我们发起请求。

在 HTTP 协议中，每一个异步请求都会携带两个 Header，用于标记来源域名：

- Origin Header
- Referer Header

这两个 Header 在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个 Header 中的域名，确定请求的来源域。同时服务器应该优先检测 Origin。为了安全考虑，相比于 Referer，Origin 只包含了域名而不带路径。

#### CSRF Token

服务端可以通过响应头的 set-cookie 给浏览器下发一个随机值 token，让后续每次发起的请求 在 header 或者 body 或者 queryString 中植入它。

上文讲述，页面的 JS 脚本读写 cookie 有跨域限制，即只能读取同源 cookie，所以服务端接口就可以通过请求报文中是否含有 token，以及含有的 token 是否是自己下发的 来判断该请求是否来自可信任的页面。

#### 给 Cookie 设置合适的 SameSite

> 该属性需要浏览器支持

当从 A 网站登录后，会从响应头中返回服务器设置的 Cookie 信息，而如果 Cookie 携带了 SameSite=strict 则表示完全禁用第三方站点请求头携带 Cookie，比如当从 B 网站请求 A 网站接口的时候，浏览器的请求头将不会携带该 Cookie。

- Samesite=Strict，这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie
- Samesite=Lax，这种称为宽松模式，比 Strict 放宽了点限制：假如这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个 GET 请求，则这个 Cookie 可以作为第三方 Cookie。（默认）
- None 任何情况下都会携带；

## 点击劫持

点击劫持（Clickjacking）是一种通过视觉欺骗的手段来达到攻击目的手段。往往是攻击者将目标网站通过 iframe 嵌入到自己的网页中，通过 opacity 等手段设置 iframe 为透明的，使得肉眼不可见，这样一来当用户在攻击者的网站中操作的时候，比如点击某个按钮（这个按钮的顶层其实是 iframe），从而实现目标网站被点击劫持。

### 防范

#### 1.设置不允许被 iframe 嵌套

在 HTTP 响应头中加入 X-FRAME-OPTIONS 属性，此属性控制页面是否可被嵌入 iframe 中，后端部署时控制

- DENY：不能被所有网站嵌套或加载；
- SAMEORIGIN：只能被同域网站嵌套或加载；
- ALLOW-FROM URL：可以被指定网站嵌套或加载。

#### 2.当被 iframe 嵌套时做处理

通过比较 window.self（当前窗口对象）和 window.top（顶层窗口对象）可以判断是否正在被 iframe 嵌套

```js
if (window.self !== window.top) {
  // 检测到嵌套时该干的事
  // 可以是跳转等操作
}
```

## 暴力攻击

暴力破解攻击是获取 Web 应用登录信息相当直接的一种方式。但同时也是非常容易缓解的攻击方式之一，尤其是从用户侧加以缓解最为方便。

暴力破解攻击中，攻击者试图猜解用户名和密码对，以便登录用户账户。当然，即使采用多台计算机，除非密码相当简单且明显，否则破解过程可能需耗费几年时间。

### 防范方法

1. 用户信息加密
2. 接口加密
3. 强密码

## 源码暴露

很多情况下服务器端会使用各种框架去开发，目录组织都是相似的，如果没有做任何配置就将目录结构暴露出来时很危险的事情。

前端代码都是要下载到端进行执行的，所以前端并没有秘密，我们说的源码暴露指的是后端代码的暴露。

### 防范方法

1. 代码混淆;
2. 通过配置使得后端代码不可以直接通过路由可以访问得到。

## DDoS 攻击

分布式拒绝服务（DDoS）攻击是通过大规模互联网流量淹没目标服务器或其周边基础设施，以破坏目标服务器、服务或网络正常流量的恶意行为。

DDoS 攻击利用多台受损计算机系统作为攻击流量来源以达到攻击效果。利用的机器可以包括计算机，也可以包括其他联网资源（如 IoT 设备）。

总体而言，DDoS 攻击好比高速公路发生交通堵塞，妨碍常规车辆抵达预定目的地。

这种攻击前端是没办法，得看后端处理。

## web 安全开发原则

web 安全开发更多的在于后端，前端因为是运行在用户端，因此是没有安全性可言的，但是前端可以通过一些措施，去提高攻击的门槛。

- 对重要信息加密解密；
- 不要将用户敏感信息打印到 HTML 文档上；
- 尽量不要从 URL 获取数据，建立参数白名单；
- https 是安全的，资源使用 HTTPS；
- 通过 csp 设置网站白名单;
- 确保第三方资源（库）安全再使用；
- 域白名单，确保接口在其他域下无法使用；
- 上传不能让用户定义路径、文件名，限制好可上传的文件类型；
- 在设置密码之类的功能上应加入密码强度要求；
